from pathlib import Path
import requests
from hashlib import md5
from shutil import rmtree
from sirhurt.exceptions import AlreadyInjectedError
from sirhurt.client import InjectedClient
from sirhurt.roblox import RobloxProcess
from .constants import APP_PATHS


class Exploit:
    """
    Wrapper for SirHurt, currently it does not support downloading official SirHurt GUI.

    Based on my old SirHurtAPI C# code.
    """

    LATEST_DOWNLOAD_URL = "https://sirhurt.net/asshurt/update/v4/fetch_version.php"
    LATEST_HASH_URL = "https://sirhurt.net/asshurt/update/v4/fetch_sirhurt_version.php"

    def __init__(self):
        self._session: requests.ClientSession = requests.Session()
        self._data: Path = Path(APP_PATHS.user_data_dir)
        self._workspace: Path = self._data.joinpath("workspace")
        self._cache: Path = Path(APP_PATHS.user_cache_dir)
        self._data.mkdir(parents=True, exist_ok=True)
        self._cache.mkdir(parents=True, exist_ok=True)
        self._workspace.mkdir(exist_ok=True)
        self._dll_path = self._data.joinpath("SirHurt.dll")

    def get_latest_url(self) -> str:
        """
        Get the latest DLL download URL.

        Returns: Download URL for the latest DLL.
        """
        rsp = self._session.get(self.LATEST_DOWNLOAD_URL)
        rsp.raise_for_status()
        return rsp.text

    def get_latest_md5(self) -> str:
        """
        Get the latest SirHurt MD5 hash.

        Returns: MD5 hash of the latest SirHurt version.
        """
        rsp = self._session.get(self.LATEST_HASH_URL)
        rsp.raise_for_status()
        return rsp.text

    def get_current_md5(self) -> str:
        if not self._dll_path.is_file():
            raise FileNotFoundError("Exploit DLL isn't downloaded.")
        return md5(self._dll_path.read_bytes()).hexdigest()

    def is_update_available(self) -> bool:
        if not self._dll_path.is_file():
            return True
        if self.get_current_md5() != self.get_latest_md5():
            return True
        return False

    def download_dll(self):
        """
        Download the current SirHurt.dll
        """
        url = self.get_latest_url()
        rsp = self._session.get(url)
        rsp.raise_for_status()
        with self._dll_path.open("wb") as f:
            for chunk in rsp.iter_content(chunk_size=1024):
                f.write(chunk)
        # Workaround
        self._data.joinpath("SirHurt V4.exe").touch(exist_ok=True)
        return self._dll_path

    def inject(self, roblox: RobloxProcess, force: bool = False, onclose=None):
        if not self._dll_path.is_file():
            raise FileNotFoundError("Exploit DLL isn't downloaded.")

        # Symlink DLL, allowing multiple instances.
        name = f"{roblox._pid}-{roblox._wine_pid}"
        cur_path = self._cache.joinpath(f"rbx/{name}/")
        if cur_path.is_dir():
            if not force:
                raise AlreadyInjectedError("Exploit is already injected.")
            rmtree(cur_path)
        cur_path.mkdir(exist_ok=True, parents=True)
        # Workaround the initial message box.
        cur_path.joinpath("org_path.txt").write_text(str(cur_path) + "/")
        cur_path.joinpath("SirHurt V4.exe").touch(exist_ok=True)
        # The fake dll we symlinked.
        cur_dll = cur_path.joinpath("SirHurt.dll")
        # Assuming sirhurt.dat is next to SirHurt.dll
        # SirHurt will read scripts from this file.
        script_file = cur_path.joinpath("sirhurt.dat")
        if cur_dll.is_file():
            cur_dll.unlink()
        cur_dll.symlink_to(self._dll_path)
        # Workaround for workspace folder (symlinking)
        cur_path.joinpath("Workspace").symlink_to(
            self._workspace, target_is_directory=True
        )

        def hook():
            # Cleanup
            rmtree(cur_path)
            # Callback
            if onclose:
                onclose()

        roblox.inject(cur_dll, onclose=hook)
        return InjectedClient(roblox=roblox, target_file=script_file)
